<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Commands - LAIKA</title>
    <link rel="stylesheet" href="css/header-footer.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap');

        :root {
            --atomic-cyan: #00FFFF;
            --tron-cyan: #00E5FF;
            --dark-cyan: #00BCD4;
            --electric-blue: #0080FF;
            --atomic-bg: #0A0A0F;
            --panel-bg: #141420;
            --grid-color: #00FFFF33;
            --text-cyan: #E0FFFF;
            --text-dim: #80C0C0;
            --glow-cyan: #00FFFF80;
            --atomic-orange: #FF6B35;
            --atomic-pink: #FF1B8D;
            --warning-yellow: #FFD700;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Exo 2', 'Orbitron', monospace;
            background: var(--atomic-bg);
            background-image: 
                radial-gradient(circle at 25% 25%, var(--grid-color) 1px, transparent 1px),
                radial-gradient(circle at 75% 75%, var(--grid-color) 1px, transparent 1px),
                linear-gradient(135deg, var(--atomic-bg) 0%, #0F0F1A 50%, var(--atomic-bg) 100%);
            background-size: 40px 40px, 40px 40px, 100% 100%;
            background-attachment: fixed;
            min-height: 100vh;
            color: var(--text-cyan);
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 80px 20px 20px;
        }

        .page-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: linear-gradient(135deg, var(--panel-bg), #1A1A30);
            border: 2px solid var(--atomic-cyan);
            box-shadow: 0 0 30px var(--glow-cyan);
        }

        .page-title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            color: var(--atomic-cyan);
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px var(--glow-cyan);
        }

        .page-subtitle {
            font-family: 'Exo 2', sans-serif;
            font-size: 14px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .llm-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .llm-panel {
            background: linear-gradient(135deg, var(--panel-bg), #1A1A30);
            border: 2px solid var(--atomic-cyan);
            padding: 20px;
            box-shadow: 0 0 20px var(--glow-cyan);
        }

        .panel-title {
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            color: var(--atomic-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            text-shadow: 0 0 5px var(--glow-cyan);
        }

        .command-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .cmd-btn {
            background: linear-gradient(135deg, var(--electric-blue), var(--tron-cyan));
            border: none;
            color: white;
            padding: 12px 16px;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 128, 255, 0.3);
        }

        .cmd-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 128, 255, 0.5);
        }

        .cmd-btn:active {
            transform: translateY(0);
        }

        .history-container {
            height: 400px;
            overflow-y: auto;
            border: 1px solid var(--atomic-cyan);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
        }

        .history-item {
            margin-bottom: 15px;
            padding: 10px;
            border-left: 3px solid var(--atomic-cyan);
            background: rgba(0, 255, 255, 0.05);
        }

        .history-timestamp {
            font-size: 10px;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .history-input {
            color: var(--atomic-cyan);
            font-weight: 600;
            margin-bottom: 5px;
        }

        .history-source {
            font-size: 10px;
            color: var(--warning-yellow);
            text-transform: uppercase;
        }

        .history-response {
            color: var(--text-cyan);
            font-size: 12px;
            margin-top: 5px;
            font-style: italic;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-success { background: #4CAF50; }
        .status-error { background: #F44336; }
        .status-pending { background: var(--warning-yellow); }

        .clear-btn {
            background: var(--atomic-orange);
            border: none;
            color: white;
            padding: 8px 12px;
            font-family: 'Orbitron', monospace;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .llm-grid {
                grid-template-columns: 1fr;
            }
            
            .command-buttons {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-header">
            <h1 class="page-title">ðŸ¤– LLM Commands</h1>
            <p class="page-subtitle">Direct robot control via LLM endpoints</p>
        </div>

        <div class="llm-grid">
            <div class="llm-panel">
                <h3 class="panel-title">Quick Commands</h3>
                <div class="command-buttons">
                    <button class="cmd-btn" onclick="sendLLMCommand('sit')">Sit</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('stand')">Stand</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('wave')">Wave</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('dance')">Dance</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('hello')">Hello</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('bow')">Bow</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('lie')">Lie</button>
                    <button class="cmd-btn" onclick="sendLLMCommand('stop')">Stop</button>
                </div>
            </div>

            <div class="llm-panel">
                <h3 class="panel-title">Status & Config</h3>
                <div id="status-display">
                    <div><span class="status-indicator status-pending"></span>Connecting to LLM...</div>
                    </div>
                <div style="margin-top: 15px;">
                    <label style="font-size: 12px; color: var(--text-dim);">Model:</label>
                    <select id="model-select" style="width: 100%; margin-top: 5px; background: var(--panel-bg); color: var(--text-cyan); border: 1px solid var(--atomic-cyan); padding: 5px;">
                        <option value="gpt-5">GPT-5</option>
                        <option value="gpt-4o-mini">GPT-4o Mini</option>
                        <option value="gpt-4o">GPT-4o</option>
                        <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="llm-grid">
            <div class="llm-panel">
                <h3 class="panel-title">System Prompt</h3>
                <textarea id="system-prompt" style="width: 100%; height: 120px; background: rgba(0,0,0,0.3); color: var(--text-cyan); border: 1px solid var(--atomic-cyan); padding: 10px; font-family: 'Exo 2', monospace; font-size: 12px; resize: vertical;" placeholder="Enter system prompt for LAIKA..."></textarea>
                <div style="margin-top: 10px;">
                    <button class="cmd-btn" onclick="loadCurrentPrompt()">Load Current</button>
                    <button class="cmd-btn" onclick="updatePrompt()">Update Prompt</button>
                    <button class="cmd-btn" onclick="resetPrompt()">Reset Default</button>
                </div>
            </div>

            <div class="llm-panel">
                <h3 class="panel-title">Context & Sensors</h3>
                <div style="margin-bottom: 15px;">
                    <button class="cmd-btn" onclick="refreshContext()">Refresh Context</button>
                    <button class="cmd-btn" onclick="captureContext()">Capture Context</button>
                </div>
                <div id="context-status" style="font-size: 12px; color: var(--text-dim); margin-bottom: 10px;">
                    Context: Loading...
                </div>
                <div id="sensors-status" style="font-size: 12px; color: var(--text-dim);">
                    Sensors: Loading...
                </div>
            </div>
        </div>

        <div class="llm-grid">
            <div class="llm-panel">
                <h3 class="panel-title">Current Context Image</h3>
                <div id="context-image-container" style="text-align: center; min-height: 200px; border: 1px solid var(--atomic-cyan); background: rgba(0,0,0,0.3); padding: 10px;">
                    <div style="color: var(--text-dim);">Loading context image...</div>
                </div>
                <div style="margin-top: 10px;">
                    <button class="cmd-btn" onclick="viewContextImage()">View Full Size</button>
                    <button class="cmd-btn" onclick="downloadContextImage()">Download</button>
                </div>
            </div>

            <div class="llm-panel">
                <h3 class="panel-title">Current Sensors Data</h3>
                <div id="sensors-data-container" style="height: 200px; overflow-y: auto; border: 1px solid var(--atomic-cyan); background: rgba(0,0,0,0.3); padding: 10px; font-family: 'Exo 2', monospace; font-size: 11px;">
                    <div style="color: var(--text-dim);">Loading sensors data...</div>
                </div>
                <div style="margin-top: 10px;">
                    <button class="cmd-btn" onclick="refreshSensors()">Refresh</button>
                    <button class="cmd-btn" onclick="downloadSensors()">Download JSON</button>
                </div>
            </div>
        </div>

        <div class="llm-panel" style="margin-bottom: 20px;">
            <h3 class="panel-title">Custom Input</h3>
            <div style="display: flex; gap: 10px; align-items: flex-end;">
                <div style="flex: 1;">
                    <input type="text" id="custom-input" placeholder="Enter custom command or text..." style="width: 100%; background: rgba(0,0,0,0.3); color: var(--text-cyan); border: 1px solid var(--atomic-cyan); padding: 10px; font-family: 'Exo 2', monospace;">
                </div>
                <button class="cmd-btn" onclick="sendCustomInput()">Send to LLM</button>
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 12px; color: var(--text-dim);">
                    <input type="checkbox" id="execute-actions" checked> Execute robot actions from LLM response
                    </label>
            </div>
        </div>

        <div class="llm-panel">
            <h3 class="panel-title">LLM History</h3>
            <button class="clear-btn" onclick="clearHistory()">Clear History</button>
            <div class="history-container" id="history-container">
                <div class="history-item">
                    <div class="history-timestamp">Waiting for LLM inputs...</div>
                </div>
            </div>
        </div>

        <div class="llm-panel">
            <h3 class="panel-title">ðŸ“‹ System Logs</h3>
            <div style="margin-bottom: 10px;">
                <button class="cmd-btn" onclick="clearLogs()">Clear Logs</button>
                <button class="cmd-btn" onclick="downloadLogs()">Download Logs</button>
                <button class="cmd-btn" onclick="refreshLogs()">Refresh</button>
            </div>
            <div id="logs-container" style="height: 300px; overflow-y: auto; border: 1px solid var(--atomic-cyan); background: rgba(0,0,0,0.3); padding: 10px; font-family: 'Exo 2', monospace; font-size: 11px; line-height: 1.4;">
                <div style="color: var(--text-dim);">Loading system logs...</div>
            </div>
            
            <!-- API Key Configuration -->
            <div class="llm-panel" style="margin-top: 20px;">
                <h3>ðŸ”‘ API Keys</h3>
                <div style="margin-top: 15px;">
                    <div style="margin-bottom: 15px;">
                        <label for="openai-api-key" style="display: block; margin-bottom: 5px; color: var(--text-cyan);">OpenAI API Key:</label>
                        <input type="password" id="openai-api-key" placeholder="Enter OpenAI API key" 
                               style="width: 100%; padding: 8px; background: rgba(0,0,0,0.5); border: 1px solid var(--atomic-cyan); color: var(--text-cyan); border-radius: 3px; margin-bottom: 10px;">
                        <div style="display: flex; gap: 10px;">
                            <button onclick="saveApiKey('openai_api_key', 'openai-api-key')" 
                                    style="padding: 8px 16px; background: var(--atomic-cyan); color: black; border: none; border-radius: 3px; cursor: pointer;">ðŸ’¾ Save</button>
                            <button onclick="testApiKey('openai', 'openai-api-key')" 
                                    style="padding: 8px 16px; background: var(--atomic-orange); color: black; border: none; border-radius: 3px; cursor: pointer;">ðŸ§ª Test</button>
                        </div>
                        <div id="openai-status" style="margin-top: 8px; padding: 5px; border-radius: 3px; font-size: 0.9em;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let llmHistory = [];
        let ws = null;

        // Initialize WebSocket connection
        function initWebSocket() {
            try {
                ws = new WebSocket(`ws://${window.location.host}/socket.io/?EIO=4&transport=websocket`);
                
                ws.onopen = function() {
                    console.log('ðŸ”Œ WebSocket connected');
                    updateStatus('Connected to LLM', 'success');
                    // Subscribe to LLM events
                    ws.send(JSON.stringify({type: 'subscribe_llm_history'}));
                };
                
                ws.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'llm_history_update') {
                            addHistoryItem(data.data);
                        }
                    } catch (e) {
                        console.error('WebSocket message parse error:', e);
                    }
                };
                
                ws.onclose = function() {
                    console.log('ðŸ”Œ WebSocket disconnected');
                    updateStatus('Disconnected from LLM', 'error');
                    // Try to reconnect after 3 seconds
                    setTimeout(initWebSocket, 3000);
                };
                
                ws.onerror = function(error) {
                    console.error('ðŸ”Œ WebSocket error:', error);
                    updateStatus('WebSocket error', 'error');
                };
                
            } catch (error) {
                console.error('Failed to initialize WebSocket:', error);
                updateStatus('WebSocket failed', 'error');
            }
        }

        // Send LLM command
        async function sendLLMCommand(action) {
            const timestamp = new Date().toISOString();
            
            // Add to history immediately
            addHistoryItem({
                input: action,
                source: 'web_llm_page',
                timestamp: timestamp,
                type: 'command',
                status: 'pending'
            });

            try {
                const response = await fetch(`/llm/${action}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();
                
                // Update the last history item with response
                if (llmHistory.length > 0) {
                    const lastItem = llmHistory[llmHistory.length - 1];
                    lastItem.response = result.message;
                    lastItem.status = result.success ? 'success' : 'error';
                    lastItem.action_executed = result.success;
                }
                
                updateHistoryDisplay();
                updateStatus(`Command ${action}: ${result.success ? 'Success' : 'Failed'}`, result.success ? 'success' : 'error');
                
            } catch (error) {
                console.error('LLM command error:', error);
                if (llmHistory.length > 0) {
                    llmHistory[llmHistory.length - 1].status = 'error';
                    llmHistory[llmHistory.length - 1].response = `Error: ${error.message}`;
                }
                updateHistoryDisplay();
                updateStatus(`Command ${action}: Error`, 'error');
            }
        }

        // Add history item
        function addHistoryItem(item) {
            llmHistory.push({
                ...item,
                timestamp: item.timestamp || new Date().toISOString(),
                id: Date.now() + Math.random()
            });
            
            // Keep only last 100 items
            if (llmHistory.length > 100) {
                llmHistory = llmHistory.slice(-100);
            }
            
            updateHistoryDisplay();
        }

        // Update history display
        function updateHistoryDisplay() {
            const container = document.getElementById('history-container');
            
            if (llmHistory.length === 0) {
                container.innerHTML = '<div class="history-item"><div class="history-timestamp">No LLM history yet...</div></div>';
                return;
            }
            
            container.innerHTML = llmHistory.slice().reverse().map(item => {
                const timestamp = new Date(item.timestamp).toLocaleTimeString();
                const statusClass = item.status === 'success' ? 'status-success' : 
                                  item.status === 'error' ? 'status-error' : 'status-pending';
                
                return `
                    <div class="history-item">
                        <div class="history-timestamp">${timestamp}</div>
                        <div class="history-input">
                            <span class="status-indicator ${statusClass}"></span>
                            Input: "${item.input}"
                    </div>
                        <div class="history-source">Source: ${item.source || 'unknown'} | Type: ${item.type || 'unknown'}</div>
                        ${item.response ? `<div class="history-response">Response: ${item.response}</div>` : ''}
                    </div>
                `;
            }).join('');
            
            // Scroll to top to show newest items
            container.scrollTop = 0;
        }

        // Update status
        function updateStatus(message, type) {
            const statusDisplay = document.getElementById('status-display');
            const statusClass = type === 'success' ? 'status-success' : 
                              type === 'error' ? 'status-error' : 'status-pending';
            
            statusDisplay.innerHTML = `<div><span class="status-indicator ${statusClass}"></span>${message}</div>`;
        }

        // Send custom input
        async function sendCustomInput() {
            const input = document.getElementById('custom-input').value.trim();
            if (!input) return;
            
            const timestamp = new Date().toISOString();
            
            // Add to history immediately
            addHistoryItem({
                input: input,
                source: 'web_llm_custom',
                timestamp: timestamp,
                type: 'custom_text',
                status: 'pending'
            });
            
            try {
                const response = await fetch('/llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        input: input,
                        type: 'text',
                        source: 'web_llm_page',
                        execute_actions: document.getElementById('execute-actions').checked,
                        model: document.getElementById('model-select').value
                    })
                });
                
                const result = await response.json();
                
                // Update the last history item with response
                if (llmHistory.length > 0) {
                    const lastItem = llmHistory[llmHistory.length - 1];
                    lastItem.response = result.response || result.message;
                    lastItem.status = result.success ? 'success' : 'error';
                    lastItem.action_executed = result.action_executed;
                    lastItem.tokens_used = result.tokens_used;
                    lastItem.estimated_cost = result.estimated_cost;
                }
                
                updateHistoryDisplay();
                updateStatus(`Custom input: ${result.success ? 'Success' : 'Failed'}`, result.success ? 'success' : 'error');
                
                // Clear input
                document.getElementById('custom-input').value = '';
                
            } catch (error) {
                console.error('Custom input error:', error);
                if (llmHistory.length > 0) {
                    llmHistory[llmHistory.length - 1].status = 'error';
                    llmHistory[llmHistory.length - 1].response = `Error: ${error.message}`;
                }
                updateHistoryDisplay();
                updateStatus('Custom input: Error', 'error');
            }
        }

        // Load current prompt
        async function loadCurrentPrompt() {
            try {
                const response = await fetch('/api/llm/prompt');
                const result = await response.json();
                if (result.success) {
                    document.getElementById('system-prompt').value = result.prompt;
                    updateStatus('Prompt loaded', 'success');
                } else {
                    updateStatus('Failed to load prompt', 'error');
                }
            } catch (error) {
                console.error('Load prompt error:', error);
                updateStatus('Load prompt error', 'error');
            }
        }

        // Update prompt
        async function updatePrompt() {
            const prompt = document.getElementById('system-prompt').value;
            try {
                const response = await fetch('/api/llm/prompt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                });

                const result = await response.json();
                updateStatus(result.success ? 'Prompt updated' : 'Failed to update prompt', result.success ? 'success' : 'error');
                
            } catch (error) {
                console.error('Update prompt error:', error);
                updateStatus('Update prompt error', 'error');
            }
        }

        // Reset to default prompt
        async function resetPrompt() {
            try {
                const response = await fetch('/api/llm/prompt/reset', {
                    method: 'POST'
                });

                const result = await response.json();
                if (result.success) {
                    document.getElementById('system-prompt').value = result.prompt;
                    updateStatus('Prompt reset to default', 'success');
                } else {
                    updateStatus('Failed to reset prompt', 'error');
                }
            } catch (error) {
                console.error('Reset prompt error:', error);
                updateStatus('Reset prompt error', 'error');
            }
        }

        // Enhanced history display with more details
        function updateHistoryDisplay() {
            const container = document.getElementById('history-container');
            
            if (llmHistory.length === 0) {
                container.innerHTML = '<div class="history-item"><div class="history-timestamp">No LLM history yet...</div></div>';
                return;
            }
            
            container.innerHTML = llmHistory.slice().reverse().map(item => {
                const timestamp = new Date(item.timestamp).toLocaleTimeString();
                const statusClass = item.status === 'success' ? 'status-success' : 
                                  item.status === 'error' ? 'status-error' : 'status-pending';
                
                let details = '';
                if (item.tokens_used) {
                    details += `<div style="font-size: 10px; color: var(--text-dim);">Tokens: ${item.tokens_used}</div>`;
                }
                if (item.estimated_cost) {
                    details += `<div style="font-size: 10px; color: var(--text-dim);">Cost: $${item.estimated_cost}</div>`;
                }
                if (item.action_executed !== undefined) {
                    details += `<div style="font-size: 10px; color: ${item.action_executed ? 'var(--atomic-cyan)' : 'var(--atomic-orange)'};">Action: ${item.action_executed ? 'Executed' : 'Not executed'}</div>`;
                }
                
                return `
                    <div class="history-item">
                        <div class="history-timestamp">${timestamp}</div>
                        <div class="history-input">
                            <span class="status-indicator ${statusClass}"></span>
                            Input: "${item.input}"
                        </div>
                        <div class="history-source">Source: ${item.source || 'unknown'} | Type: ${item.type || 'unknown'}</div>
                        ${item.response ? `<div class="history-response">Response: ${item.response}</div>` : ''}
                        ${details}
                    </div>
                `;
            }).join('');
            
            // Scroll to top to show newest items
            container.scrollTop = 0;
        }

        // Handle Enter key in custom input
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('custom-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendCustomInput();
                }
            });
        });

        // Clear history
        function clearHistory() {
            llmHistory = [];
            updateHistoryDisplay();
            updateStatus('History cleared', 'success');
        }

        // Context and Sensors Functions
        async function refreshContext() {
            try {
                updateStatus('Refreshing context...', 'pending');
                const response = await fetch('/api/llm/context/refresh', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    updateStatus('Context refreshed', 'success');
                    loadContextImage();
                    updateContextStatus(result.data);
                } else {
                    updateStatus('Failed to refresh context', 'error');
                }
            } catch (error) {
                console.error('Refresh context error:', error);
                updateStatus('Context refresh error', 'error');
            }
        }

        async function captureContext() {
            try {
                updateStatus('Capturing context...', 'pending');
                const response = await fetch('/api/llm/context/capture', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    updateStatus('Context captured', 'success');
                    loadContextImage();
                    updateContextStatus(result.data);
                } else {
                    updateStatus('Failed to capture context', 'error');
                }
            } catch (error) {
                console.error('Capture context error:', error);
                updateStatus('Context capture error', 'error');
            }
        }

        async function loadContextImage() {
            try {
                const response = await fetch('/api/llm/context/image');
                if (response.ok) {
                    const blob = await response.blob();
                    const imageUrl = URL.createObjectURL(blob);
                    
                    const container = document.getElementById('context-image-container');
                    container.innerHTML = `<img src="${imageUrl}" style="max-width: 100%; max-height: 180px; border: 1px solid var(--atomic-cyan);" alt="Context Image">`;
                } else {
                    document.getElementById('context-image-container').innerHTML = 
                        '<div style="color: var(--atomic-orange);">No context image available</div>';
                }
            } catch (error) {
                console.error('Load context image error:', error);
                document.getElementById('context-image-container').innerHTML = 
                    '<div style="color: var(--atomic-orange);">Error loading context image</div>';
            }
        }

        async function loadSensorsData() {
            try {
                const response = await fetch('/api/llm/sensors');
                if (response.ok) {
                    const data = await response.json();
                    
                    const container = document.getElementById('sensors-data-container');
                    container.innerHTML = `<pre style="color: var(--text-cyan); margin: 0;">${JSON.stringify(data, null, 2)}</pre>`;
                    
                    updateSensorsStatus(data);
                } else {
                    document.getElementById('sensors-data-container').innerHTML = 
                        '<div style="color: var(--atomic-orange);">No sensors data available</div>';
                }
            } catch (error) {
                console.error('Load sensors error:', error);
                document.getElementById('sensors-data-container').innerHTML = 
                    '<div style="color: var(--atomic-orange);">Error loading sensors data</div>';
            }
        }

        async function refreshSensors() {
            try {
                updateStatus('Refreshing sensors...', 'pending');
                const response = await fetch('/api/llm/sensors/refresh', {
                    method: 'POST'
                });
                const result = await response.json();
                
                if (result.success) {
                    updateStatus('Sensors refreshed', 'success');
                    loadSensorsData();
                } else {
                    updateStatus('Failed to refresh sensors', 'error');
                }
            } catch (error) {
                console.error('Refresh sensors error:', error);
                updateStatus('Sensors refresh error', 'error');
            }
        }

        function updateContextStatus(data) {
            const statusElement = document.getElementById('context-status');
            if (data && data.timestamp) {
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                statusElement.innerHTML = `Context: ${data.capture_method || 'unknown'} - ${timestamp}`;
            } else {
                statusElement.innerHTML = 'Context: No data available';
            }
        }

        function updateSensorsStatus(data) {
            const statusElement = document.getElementById('sensors-status');
            if (data && data.timestamp) {
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                const robotStatus = data.robot ? data.robot.status || 'unknown' : 'unknown';
                statusElement.innerHTML = `Sensors: ${robotStatus} - ${timestamp}`;
            } else {
                statusElement.innerHTML = 'Sensors: No data available';
            }
        }

        function viewContextImage() {
            const container = document.getElementById('context-image-container');
            const img = container.querySelector('img');
            if (img) {
                window.open(img.src, '_blank');
            } else {
                alert('No context image available');
            }
        }

        async function downloadContextImage() {
            try {
                const response = await fetch('/api/llm/context/image');
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `context_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.jpg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('No context image available for download');
                }
            } catch (error) {
                console.error('Download context image error:', error);
                alert('Error downloading context image');
            }
        }

        async function downloadSensors() {
            try {
                const response = await fetch('/api/llm/sensors');
                if (response.ok) {
                    const data = await response.json();
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `sensors_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('No sensors data available for download');
                }
            } catch (error) {
                console.error('Download sensors error:', error);
                alert('Error downloading sensors data');
            }
        }

        // Logs functions
        async function refreshLogs() {
            try {
                const response = await fetch('/api/llm/logs');
                if (response.ok) {
                    const logs = await response.json();
                    displayLogs(logs);
                    updateStatus('Logs refreshed', 'success');
                } else {
                    updateStatus('Failed to fetch logs', 'error');
                }
            } catch (error) {
                console.error('Refresh logs error:', error);
                updateStatus('Logs refresh error', 'error');
            }
        }

        function displayLogs(logs) {
            const container = document.getElementById('logs-container');
            if (!logs || logs.length === 0) {
                container.innerHTML = '<div style="color: var(--text-dim);">No logs available</div>';
                return;
            }

            let html = '';
            logs.forEach(log => {
                const timestamp = new Date(log.timestamp).toLocaleString();
                const level = log.level || 'INFO';
                const levelColor = getLogLevelColor(level);
                html += `
                    <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(0, 255, 255, 0.1); padding-bottom: 4px;">
                        <span style="color: var(--text-dim); font-size: 10px;">${timestamp}</span>
                        <span style="color: ${levelColor}; font-weight: bold; margin-left: 8px;">[${level}]</span>
                        <span style="color: var(--text-cyan); margin-left: 8px;">${log.message}</span>
                    </div>
                `;
            });
            container.innerHTML = html;
            container.scrollTop = container.scrollHeight; // Auto-scroll to bottom
        }

        function getLogLevelColor(level) {
            switch (level.toUpperCase()) {
                case 'ERROR': return '#FF6B6B';
                case 'WARNING': return '#FFD93D';
                case 'INFO': return '#6BCF7F';
                case 'DEBUG': return '#4ECDC4';
                default: return '#E0FFFF';
            }
        }

        function clearLogs() {
            const container = document.getElementById('logs-container');
            container.innerHTML = '<div style="color: var(--text-dim);">Logs cleared</div>';
        }

        async function downloadLogs() {
            try {
                const response = await fetch('/api/llm/logs');
                if (response.ok) {
                    const logs = await response.json();
                    const logText = logs.map(log => 
                        `${new Date(log.timestamp).toISOString()} [${log.level || 'INFO'}] ${log.message}`
                    ).join('\n');
                    
                    const blob = new Blob([logText], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `laika_logs_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    alert('No logs available for download');
                }
            } catch (error) {
                console.error('Download logs error:', error);
                alert('Error downloading logs');
            }
        }

        // Global functions for API key management
        async function saveApiKey(keyName, inputId) {
            const input = document.getElementById(inputId);
            const apiKey = input.value.trim();
            
            if (!apiKey) {
                showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Please enter an API key', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/keys', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ [keyName]: apiKey })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showApiKeyStatus(inputId.replace('-api-key', '-status'), 'API key saved successfully!', 'success');
                    input.value = apiKey.substring(0, 8) + '...' + apiKey.substring(apiKey.length - 4);
                } else {
                    showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Failed to save API key: ' + data.error, 'error');
                }
            } catch (error) {
                showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Error saving API key: ' + error.message, 'error');
            }
        }
        
        async function testApiKey(service, inputId) {
            const input = document.getElementById(inputId);
            const apiKey = input.value.trim();
            
            if (!apiKey) {
                showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Please enter an API key to test', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/keys/test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ service: service, api_key: apiKey })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const testResult = data.test_results[service === 'openai' ? 'llm' : service];
                    if (testResult && testResult.success) {
                        showApiKeyStatus(inputId.replace('-api-key', '-status'), testResult.message, 'success');
                    } else {
                        showApiKeyStatus(inputId.replace('-api-key', '-status'), 'API key test failed: ' + (testResult?.error || 'Unknown error'), 'error');
                    }
                } else {
                    showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Test failed: ' + data.error, 'error');
                }
            } catch (error) {
                showApiKeyStatus(inputId.replace('-api-key', '-status'), 'Error testing API key: ' + error.message, 'error');
            }
        }
        
        function showApiKeyStatus(statusId, message, type) {
            const statusElement = document.getElementById(statusId);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.background = type === 'success' ? 'rgba(0, 255, 0, 0.1)' : 
                                                type === 'error' ? 'rgba(255, 0, 0, 0.1)' : 
                                                'rgba(0, 255, 255, 0.1)';
                statusElement.style.border = type === 'success' ? '1px solid #00ff00' : 
                                           type === 'error' ? '1px solid #ff0000' : 
                                           '1px solid #00ffff';
                statusElement.style.color = type === 'success' ? '#00ff00' : 
                                          type === 'error' ? '#ff0000' : 
                                          '#00ffff';
                
                // Clear status after 5 seconds
                setTimeout(() => {
                    statusElement.textContent = '';
                    statusElement.style.background = '';
                    statusElement.style.border = '';
                    statusElement.style.color = '';
                }, 5000);
            }
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            initWebSocket();
            updateStatus('Initializing...', 'pending');
            loadCurrentPrompt(); // Load current prompt on page load
            loadContextImage(); // Load context image
            loadSensorsData(); // Load sensors data
            refreshLogs(); // Load system logs
        });
    </script>
</body>
</html>