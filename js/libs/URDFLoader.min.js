/**
 * Real URDF-Loader for PuppyPi - Loads Actual URDF and Maps ROS2 Servo Angles
 * Based on the official urdf-loaders library from GitHub
 * https://github.com/gkjohnson/urdf-loaders
 */

(function() {
    'use strict';
    
    // URDF-Loader constructor
    function URDFLoader() {
        this.packages = {};
        this.workingPath = '';
        this.parseVisual = true;
        this.parseCollision = false;
        
        // PuppyPi joint mapping
        this.puppyJoints = {
            'rf_joint1': { type: 'hip', leg: 'rf', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'rf_joint2': { type: 'knee', leg: 'rf', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'lf_joint1': { type: 'hip', leg: 'lf', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'lf_joint2': { type: 'knee', leg: 'lf', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'rb_joint1': { type: 'hip', leg: 'rb', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'rb_joint2': { type: 'knee', leg: 'rb', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'lb_joint1': { type: 'hip', leg: 'lb', axis: 'z', limits: { lower: -1.57, upper: 1.57 } },
            'lb_joint2': { type: 'knee', leg: 'lb', axis: 'z', limits: { lower: -1.57, upper: 1.57 } }
        };
        
        this.load = function(url, callback, onProgress, onError) {
            console.log('Real URDF-Loader: Loading', url);
            
            // Fetch and parse the actual URDF file
            fetch(url)
                .then(response => response.text())
                .then(urdfContent => {
                    console.log('URDF content loaded, parsing...');
                    this.parseURDF(urdfContent, callback);
                })
                .catch(error => {
                    console.error('Failed to load URDF:', error);
                    if (onError) onError(error);
                });
        };
        
        this.parseURDF = function(urdfContent, callback) {
            console.log('Parsing URDF content, length:', urdfContent.length);
            console.log('URDF content preview:', urdfContent.substring(0, 200));
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(urdfContent, 'text/xml');
            
            // Check for parsing errors
            const parseError = xmlDoc.getElementsByTagName('parsererror');
            if (parseError.length > 0) {
                console.error('XML parsing error:', parseError[0].textContent);
                return;
            }
            
            console.log('XML parsed successfully');
            console.log('Root element:', xmlDoc.documentElement.tagName);
            console.log('Root element name:', xmlDoc.documentElement.getAttribute('name'));
            
            // Create robot group
            const robot = new THREE.Group();
            robot.name = 'PuppyPi_Robot';
            
            // Add required methods
            robot.updateMatrixWorld = function(force) {
                THREE.Group.prototype.updateMatrixWorld.call(this, force);
            };
            
            robot.joints = {};
            
            // Parse links and joints
            this.parseLinks(xmlDoc, robot, callback);
            this.parseJoints(xmlDoc, robot);
        };
        
        this.parseLinks = function(xmlDoc, robot, callback) {
            const links = xmlDoc.getElementsByTagName('link');
            console.log('Found', links.length, 'links in URDF');
            
            if (links.length === 0) {
                console.error('No links found! Checking for other elements...');
                const allElements = xmlDoc.getElementsByTagName('*');
                console.log('All elements found:', Array.from(allElements).map(el => el.tagName));
                if (callback) callback(robot);
                return;
            }
            
            let pendingSTLLoads = 0;
            let hasSTLFiles = false;
            
            // First pass: create all meshes
            for (let i = 0; i < links.length; i++) {
                const link = links[i];
                const linkName = link.getAttribute('name');
                
                console.log('Processing link:', linkName);
                
                if (linkName === 'base_footprint') {
                    console.log('Skipping base_footprint');
                    continue; // Skip footprint
                }
                
                // Parse visual elements
                const visuals = link.getElementsByTagName('visual');
                console.log('Found', visuals.length, 'visual elements for', linkName);
                
                if (visuals.length > 0) {
                    for (let j = 0; j < visuals.length; j++) {
                        const hasSTL = this.parseVisual(visuals[j], linkName, robot, () => {
                            pendingSTLLoads--;
                            console.log('STL load completed, pending:', pendingSTLLoads);
                            if (pendingSTLLoads === 0 && hasSTLFiles) {
                                console.log('All STL files loaded, calling callback');
                                console.log('Robot group has', robot.children.length, 'children after all STL loads');
                                console.log('Robot children:', robot.children.map(child => child.name));
                                if (callback) callback(robot);
                            }
                        });
                        if (hasSTL) {
                            hasSTLFiles = true;
                            pendingSTLLoads++;
                        }
                    }
                } else {
                    // No visual elements found, check for collision geometry
                    const collisions = link.getElementsByTagName('collision');
                    console.log('No visual elements, found', collisions.length, 'collision elements for', linkName);
                    
                    if (collisions.length > 0) {
                        for (let j = 0; j < collisions.length; j++) {
                            this.parseCollision(collisions[j], linkName, robot);
                        }
                    }
                }
            }
            
            // Second pass: apply joint origins to position meshes correctly
            this.applyJointOriginsToMeshes(xmlDoc, robot);
            
            // If no STL files were found, call callback immediately
            if (!hasSTLFiles) {
                console.log('No STL files found, calling callback immediately');
                console.log('Robot group has', robot.children.length, 'children after parsing');
                console.log('Robot children:', robot.children.map(child => child.name));
                if (callback) callback(robot);
            }
        };
        
        this.parseVisual = function(visual, linkName, robot, onSTLLoaded) {
            const geometry = visual.getElementsByTagName('geometry')[0];
            const material = visual.getElementsByTagName('material')[0];
            
            if (!geometry) {
                return false;
            }
            
            // Parse origin
            const origin = visual.getElementsByTagName('origin')[0];
            let xyz = [0, 0, 0];
            let rpy = [0, 0, 0];
            
            if (origin) {
                const xyzAttr = origin.getAttribute('xyz');
                const rpyAttr = origin.getAttribute('rpy');
                if (xyzAttr) xyz = xyzAttr.split(' ').map(Number);
                if (rpyAttr) rpy = rpyAttr.split(' ').map(Number);
            }
            
            // Only log leg positioning info
            if (linkName.includes('link') && (linkName.includes('lf') || linkName.includes('rf') || linkName.includes('lb') || linkName.includes('rb'))) {
                console.log('ü¶µ LEG:', linkName, '| Position:', xyz, '| Rotation:', rpy);
            }
            
            // Parse geometry
            const mesh = geometry.getElementsByTagName('mesh')[0];
            if (mesh) {
                const filename = mesh.getAttribute('filename');
                if (filename) {
                    this.loadSTLMesh(filename, linkName, xyz, rpy, robot, onSTLLoaded);
                    return true; // Indicates STL file was found
                }
            } else {
                // Fallback to simple geometry
                this.createSimpleGeometry(geometry, linkName, xyz, rpy, robot);
            }
            return false; // No STL file found
        };
        
        this.loadSTLMesh = function(filename, linkName, xyz, rpy, robot, onSTLLoaded) {
            // Convert package:// path to local path
            let meshPath = filename.replace('package://puppypi_description/meshes/', 'js/libs/meshes/');
            meshPath = meshPath.replace('package://puppy_pi_urdf/meshes/', '/puppy_pi_urdf/meshes/');
            
            // Load the actual STL file from local path
            fetch(meshPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.arrayBuffer();
                })
                .then(buffer => {
                    this.parseSTLBuffer(buffer, linkName, xyz, rpy, robot);
                    if (onSTLLoaded) onSTLLoaded();
                })
                .catch(error => {
                    console.error('‚ùå Failed to load STL for', linkName, ':', error.message);
                    // Fallback to simple geometry if STL fails
                    this.createSimpleGeometryForLink(linkName, xyz, rpy, robot);
                    if (onSTLLoaded) onSTLLoaded();
                });
        };
        
        this.parseSTLBuffer = function(buffer, linkName, xyz, rpy, robot) {
            // Parse binary STL file
            const view = new DataView(buffer);
            
            // Check if it's binary STL (80 byte header + 4 byte triangle count)
            const triangleCount = view.getUint32(80, true);
            const expectedSize = 80 + 4 + triangleCount * 50; // 50 bytes per triangle
            
            if (buffer.byteLength === expectedSize) {
                // Binary STL
                this.parseBinarySTL(view, triangleCount, linkName, xyz, rpy, robot);
            } else {
                // ASCII STL
                const text = new TextDecoder().decode(buffer);
                this.parseASCIISTL(text, linkName, xyz, rpy, robot);
            }
        };
        
        this.parseBinarySTL = function(view, triangleCount, linkName, xyz, rpy, robot) {
            const vertices = [];
            const normals = [];
            
            for (let i = 0; i < triangleCount; i++) {
                const offset = 84 + i * 50;
                
                // Normal vector (12 bytes)
                const nx = view.getFloat32(offset, true);
                const ny = view.getFloat32(offset + 4, true);
                const nz = view.getFloat32(offset + 8, true);
                
                // Vertex 1 (12 bytes)
                const v1x = view.getFloat32(offset + 12, true);
                const v1y = view.getFloat32(offset + 16, true);
                const v1z = view.getFloat32(offset + 20, true);
                
                // Vertex 2 (12 bytes)
                const v2x = view.getFloat32(offset + 24, true);
                const v2y = view.getFloat32(offset + 28, true);
                const v2z = view.getFloat32(offset + 32, true);
                
                // Vertex 3 (12 bytes)
                const v3x = view.getFloat32(offset + 36, true);
                const v3y = view.getFloat32(offset + 40, true);
                const v3z = view.getFloat32(offset + 44, true);
                
                // Add vertices and normals
                vertices.push(v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z);
                normals.push(nx, ny, nz, nx, ny, nz, nx, ny, nz);
            }
            
            this.createMeshFromVertices(vertices, normals, linkName, xyz, rpy, robot);
        };
        
        this.parseASCIISTL = function(text, linkName, xyz, rpy, robot) {
            const vertices = [];
            const normals = [];
            
            const lines = text.split('\n');
            let currentNormal = null;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('facet normal')) {
                    const parts = line.split(' ');
                    currentNormal = [
                        parseFloat(parts[2]),
                        parseFloat(parts[3]),
                        parseFloat(parts[4])
                    ];
                } else if (line.startsWith('vertex')) {
                    const parts = line.split(' ');
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                    
                    if (currentNormal) {
                        normals.push(...currentNormal);
                    }
                }
            }
            
            this.createMeshFromVertices(vertices, normals, linkName, xyz, rpy, robot);
        };
        
        this.createMeshFromVertices = function(vertices, normals, linkName, xyz, rpy, robot) {
            const geometry = new THREE.BufferGeometry();
            
            // Create Float32Arrays for vertices and normals
            const vertexArray = new Float32Array(vertices);
            const normalArray = new Float32Array(normals);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertexArray, 3));
            geometry.setAttribute('normal', new THREE.BufferAttribute(normalArray, 3));
            
            // Create material
            const colors = {
                'base_link': 0xcccccc,
                'camera_link': 0x333333,
                'lidar_frame': 0x1a1a1a,
                'lf_link1': 0x666666,
                'lf_link2': 0x666666,
                'lf_link3': 0x666666,
                'rf_link1': 0x666666,
                'rf_link2': 0x666666,
                'rf_link3': 0x666666,
                'lb_link1': 0x666666,
                'lb_link2': 0x666666,
                'lb_link3': 0x666666,
                'rb_link1': 0x666666,
                'rb_link2': 0x666666,
                'rb_link3': 0x666666
            };
            
            const color = colors[linkName] || 0x888888;
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = linkName;
            
            // Apply visual origin from URDF
            mesh.position.set(xyz[0], xyz[1], xyz[2]);
            
            // Apply rotation from URDF
            const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'ZYX');
            mesh.quaternion.setFromEuler(euler);
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            robot.add(mesh);
            
            console.log('Created STL mesh for', linkName, 'with', vertices.length / 3, 'vertices at position', xyz);
        };
        
        this.createSimpleGeometryForLink = function(linkName, xyz, rpy, robot) {
            // Fallback geometry when STL loading fails
            const colors = {
                'base_link': 0xcccccc,
                'camera_link': 0x333333,
                'lidar_frame': 0x1a1a1a,
                'lf_link1': 0x666666,
                'lf_link2': 0x666666,
                'lf_link3': 0x666666,
                'rf_link1': 0x666666,
                'rf_link2': 0x666666,
                'rf_link3': 0x666666,
                'lb_link1': 0x666666,
                'lb_link2': 0x666666,
                'lb_link3': 0x666666,
                'rb_link1': 0x666666,
                'rb_link2': 0x666666,
                'rb_link3': 0x666666
            };
            
            const color = colors[linkName] || 0x888888;
            
            // Create properly sized meshes based on link type
            let geometry;
            if (linkName === 'base_link') {
                geometry = new THREE.BoxGeometry(0.15, 0.15, 0.05); // Main body
            } else if (linkName === 'lidar_frame') {
                geometry = new THREE.CylinderGeometry(0.02, 0.02, 0.03, 8); // Lidar cylinder
            } else if (linkName.includes('link1')) {
                geometry = new THREE.BoxGeometry(0.02, 0.02, 0.08); // Upper leg segments
            } else if (linkName.includes('link2')) {
                geometry = new THREE.BoxGeometry(0.02, 0.02, 0.08); // Lower leg segments
            } else if (linkName.includes('link3')) {
                geometry = new THREE.BoxGeometry(0.02, 0.02, 0.02); // Foot segments
            } else if (linkName === 'camera_link') {
                geometry = new THREE.BoxGeometry(0.03, 0.03, 0.03); // Camera
            } else {
                geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05); // Default size
            }
            
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.9
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = linkName;
            mesh.position.set(xyz[0], xyz[1], xyz[2]);
            
            // Apply rotation
            const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'ZYX');
            mesh.quaternion.setFromEuler(euler);
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            robot.add(mesh);
            
            console.log('Created fallback geometry for', linkName, 'at position', xyz);
        };
        
        this.createSimpleGeometry = function(geometry, linkName, xyz, rpy, robot) {
            const box = geometry.getElementsByTagName('box')[0];
            const cylinder = geometry.getElementsByTagName('cylinder')[0];
            const sphere = geometry.getElementsByTagName('sphere')[0];
            
            let mesh;
            
            if (box) {
                const size = box.getAttribute('size').split(' ').map(Number);
                const geometry = new THREE.BoxGeometry(size[0], size[1], size[2]);
                const material = new THREE.MeshLambertMaterial({ color: 0xcccccc });
                mesh = new THREE.Mesh(geometry, material);
            } else if (cylinder) {
                const radius = parseFloat(cylinder.getAttribute('radius'));
                const length = parseFloat(cylinder.getAttribute('length'));
                const geometry = new THREE.CylinderGeometry(radius, radius, length, 8);
                const material = new THREE.MeshLambertMaterial({ color: 0x666666 });
                mesh = new THREE.Mesh(geometry, material);
            } else if (sphere) {
                const radius = parseFloat(sphere.getAttribute('radius'));
                const geometry = new THREE.SphereGeometry(radius, 8, 6);
                const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
                mesh = new THREE.Mesh(geometry, material);
            }
            
            if (mesh) {
                mesh.name = linkName;
                mesh.position.set(xyz[0], xyz[1], xyz[2]);
                
                const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'ZYX');
                mesh.quaternion.setFromEuler(euler);
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                robot.add(mesh);
            }
        };
        
        this.parseCollision = function(collision, linkName, robot) {
            const geometry = collision.getElementsByTagName('geometry')[0];
            
            if (!geometry) {
                console.log('No geometry found in collision for', linkName);
                return;
            }
            
            // Parse origin
            const origin = collision.getElementsByTagName('origin')[0];
            let xyz = [0, 0, 0];
            let rpy = [0, 0, 0];
            
            if (origin) {
                const xyzAttr = origin.getAttribute('xyz');
                const rpyAttr = origin.getAttribute('rpy');
                if (xyzAttr) xyz = xyzAttr.split(' ').map(Number);
                if (rpyAttr) rpy = rpyAttr.split(' ').map(Number);
            }
            
            console.log('Parsing collision for', linkName, 'at position', xyz, 'rotation', rpy);
            
            // Parse geometry
            const mesh = geometry.getElementsByTagName('mesh')[0];
            if (mesh) {
                const filename = mesh.getAttribute('filename');
                console.log('Found collision mesh file:', filename, 'for', linkName);
                if (filename) {
                    this.loadSTLMesh(filename, linkName, xyz, rpy, robot, null);
                    return;
                }
            } else {
                console.log('No collision mesh found, creating simple geometry for', linkName);
                // Create simple geometry from collision
                this.createSimpleGeometry(geometry, linkName, xyz, rpy, robot);
            }
        };
        
        this.applyJointOriginsToMeshes = function(xmlDoc, robot) {
            const joints = xmlDoc.getElementsByTagName('joint');
            console.log('Applying joint origins to meshes for', joints.length, 'joints');
            
            for (let i = 0; i < joints.length; i++) {
                const joint = joints[i];
                const jointName = joint.getAttribute('name');
                const jointType = joint.getAttribute('type');
                
                if (jointType === 'fixed') {
                    console.log('Skipping fixed joint:', jointName);
                    continue; // Skip fixed joints
                }
                
                // Parse joint origin
                const origin = joint.getElementsByTagName('origin')[0];
                let xyz = [0, 0, 0];
                let rpy = [0, 0, 0];
                
                if (origin) {
                    const xyzAttr = origin.getAttribute('xyz');
                    const rpyAttr = origin.getAttribute('rpy');
                    if (xyzAttr) xyz = xyzAttr.split(' ').map(Number);
                    if (rpyAttr) rpy = rpyAttr.split(' ').map(Number);
                }
                
                // Parse parent and child links
                const parent = joint.getElementsByTagName('parent')[0];
                const child = joint.getElementsByTagName('child')[0];
                const parentLink = parent ? parent.getAttribute('link') : null;
                const childLink = child ? child.getAttribute('link') : null;
                
                // Apply joint origin to child mesh
                if (childLink) {
                    const childMesh = robot.getObjectByName(childLink);
                    if (childMesh) {
                        console.log('Applying joint origin for', jointName, 'to', childLink, 'position:', xyz);
                        childMesh.position.set(xyz[0], xyz[1], xyz[2]);
                        
                        // Apply joint rotation
                        const euler = new THREE.Euler(rpy[0], rpy[1], rpy[2], 'ZYX');
                        childMesh.quaternion.setFromEuler(euler);
                    } else {
                        console.warn('Child mesh not found for joint', jointName, 'child:', childLink);
                    }
                }
            }
        };
        
        this.parseJoints = function(xmlDoc, robot) {
            const joints = xmlDoc.getElementsByTagName('joint');
            
            for (let i = 0; i < joints.length; i++) {
                const joint = joints[i];
                const jointName = joint.getAttribute('name');
                const jointType = joint.getAttribute('type');
                
                if (jointType === 'fixed') {
                    continue; // Skip fixed joints
                }
                
                // Parse joint origin
                const origin = joint.getElementsByTagName('origin')[0];
                let xyz = [0, 0, 0];
                let rpy = [0, 0, 0];
                
                if (origin) {
                    const xyzAttr = origin.getAttribute('xyz');
                    const rpyAttr = origin.getAttribute('rpy');
                    if (xyzAttr) xyz = xyzAttr.split(' ').map(Number);
                    if (rpyAttr) rpy = rpyAttr.split(' ').map(Number);
                }
                
                // Parse parent and child links
                const parent = joint.getElementsByTagName('parent')[0];
                const child = joint.getElementsByTagName('child')[0];
                const parentLink = parent ? parent.getAttribute('link') : null;
                const childLink = child ? child.getAttribute('link') : null;
                
                // Parse joint axis
                const axis = joint.getElementsByTagName('axis')[0];
                let axisVector = [0, 0, 1]; // Default Z axis
                if (axis) {
                    const axisAttr = axis.getAttribute('xyz');
                    if (axisAttr) axisVector = axisAttr.split(' ').map(Number);
                }
                
                // Parse joint limits
                const limit = joint.getElementsByTagName('limit')[0];
                if (limit) {
                    const lower = parseFloat(limit.getAttribute('lower') || '0');
                    const upper = parseFloat(limit.getAttribute('upper') || '0');
                    
                    // Only log leg joint info
                    if (jointName.includes('joint') && (jointName.includes('lf') || jointName.includes('rf') || jointName.includes('lb') || jointName.includes('rb'))) {
                        console.log('ü¶¥ JOINT:', jointName, '| Parent:', parentLink, '| Child:', childLink, '| Origin:', xyz, '| Rotation:', rpy, '| Axis:', axisVector, '| Limits:', lower, 'to', upper);
                    }
                    
                    robot.joints[jointName] = {
                        setJointValue: function(value) {
                            // Find the child link and apply transformation
                            const childMesh = robot.getObjectByName(childLink);
                            if (childMesh) {
                                // Apply joint origin transformation
                                childMesh.position.set(xyz[0], xyz[1], xyz[2]);
                                
                                // Apply joint rotation based on axis
                                const clampedValue = Math.max(lower, Math.min(upper, value));
                                if (axisVector[0] === 1) {
                                    childMesh.rotation.x = clampedValue;
                                } else if (axisVector[1] === 1) {
                                    childMesh.rotation.y = clampedValue;
                                } else if (axisVector[2] === 1) {
                                    childMesh.rotation.z = clampedValue;
                                }
                                
                                // Only log leg joint updates
                                if (jointName.includes('joint') && (jointName.includes('lf') || jointName.includes('rf') || jointName.includes('lb') || jointName.includes('rb'))) {
                                    console.log('üîÑ JOINT UPDATE:', jointName, '| Value:', clampedValue.toFixed(2), '| Position:', [childMesh.position.x.toFixed(3), childMesh.position.y.toFixed(3), childMesh.position.z.toFixed(3)]);
                                }
                            } else {
                                console.warn('‚ùå Child mesh not found for joint', jointName, 'child:', childLink);
                            }
                        },
                        limits: { lower: lower, upper: upper },
                        origin: { xyz: xyz, rpy: rpy },
                        axis: axisVector,
                        parent: parentLink,
                        child: childLink
                    };
                }
            }
            
            // Joint parsing is now complete with proper URDF transformations
        };
    }
    
    // Make it globally available
    if (typeof window !== 'undefined') {
        window.URDFLoader = URDFLoader;
    }
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = URDFLoader;
    }
    
})();